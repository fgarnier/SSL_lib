(**


SSL library, ssl_normalization. 

Those functions are defined to rewrite any formula of the
SSL abstract domain in a (unique) normal form.

Written by Florent Garnier, at Verimag Labs  2012 
Contact florent dot garnier at gmail dot com for  further informations.

This files is released under the terms of the LGPL v2.1 Licence.

 
This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor,
 Boston, MA  02110-1301  USA

*)




open Union_find
open List
open Hashtbl
open Ssl_types
open Ssl
open Ssl_types.SSL_lex
open Ssl_substitution



(** That is used to collect each theories generated by each ptrvar *)
 let all_aff_fold_to_theory _ (lvars : (locvar , unit) t ) (list_of_eq : SSL_lex.eq list) =
     (unify_eq lvars ) @ list_of_eq

(** Removal of uninstanciated existancially quantified variables of
a SSL formula *)
let var_elim ( sslf : ssl_formula ) =
  let iter_elim lvar () =
    if (ssl_contains_locvar lvar sslf  ) then ()
    else Hashtbl.remove sslf.quant_vars lvar
  in
  Hashtbl.iter iter_elim sslf.quant_vars
   
(** Deletes all equations of a formula*) 
let theories_cleanup (sslf : ssl_formula ) =
  sslf.pure.equations <- []
 

(** qelim removes all represent of class from the set of existentially
quantified vars, if at least one of the members of the class
is a free variable.

The case of others variable is not dealt with in this function, as
we latter eliminate all variables that doesn't appear inside the
equations, from this set.
*)
let q_elim (sslf : ssl_formula ) ( part : Union_find.partition ) =

  let q_exists_iterator part_table lvar () =
    if Hashtbl.mem part_table lvar then
      let cl =  Hashtbl.find part_table lvar in
	if ( Union_find.eqclass_exists_free_var cl sslf )
	then Hashtbl.remove sslf.quant_vars lvar
	else ()
  in
  match part with 
      Partition ( part_table ) -> 
	Hashtbl.iter (q_exists_iterator part_table) sslf.quant_vars
	

(**
Puts the formula in normal form.
 *)
let normalize_ssl ( sslf : ssl_formula ) =
  let theories = (Hashtbl.fold all_aff_fold_to_theory sslf.pure.affectations []) in
  let part = eqlist_to_partition theories in
    q_elim sslf part ;
    let subst_test = subst_from_partition part in
    subst_against_ssl subst_test sslf;
      var_elim sslf; theories_cleanup sslf
  
  


